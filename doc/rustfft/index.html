<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="RustFFT is a high-performance FFT library written in pure Rust."><title>rustfft - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rustfft" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../rustfft/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../rustfft/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate rustfft</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 6.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">rustfft</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/rustfft/lib.rs.html#1-485">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>RustFFT is a high-performance FFT library written in pure Rust.</p>
<p>RustFFT supports the AVX instruction set for increased performance. No special code is needed to activate AVX:
Simply plan a FFT using the FftPlanner on a machine that supports the <code>avx</code> and <code>fma</code> CPU features, and RustFFT
will automatically switch to faster AVX-accelerated algorithms.</p>
<p>For machines that do not have AVX, RustFFT also supports the SSE4.1 instruction set.
As for AVX, this is enabled automatically when using the FftPlanner.</p>
<p>Additionally, there is (opt-in) support for the Neon instruction set on AArch64.</p>
<h4 id="usage"><a href="#usage">Usage</a></h4>
<p>The recommended way to use RustFFT is to create a <a href="struct.FftPlanner.html" title="struct rustfft::FftPlanner"><code>FftPlanner</code></a> instance and then call its
<a href="struct.FftPlanner.html#method.plan_fft" title="method rustfft::FftPlanner::plan_fft"><code>plan_fft</code></a> method. This method will automatically choose which FFT algorithms are best
for a given size and initialize the required buffers and precomputed data.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Perform a forward FFT of size 1234
</span><span class="kw">use </span>rustfft::{FftPlanner, num_complex::Complex};

<span class="kw">let </span><span class="kw-2">mut </span>planner = FftPlanner::new();
<span class="kw">let </span>fft = planner.plan_fft_forward(<span class="number">1234</span>);

<span class="kw">let </span><span class="kw-2">mut </span>buffer = <span class="macro">vec!</span>[Complex{ re: <span class="number">0.0f32</span>, im: <span class="number">0.0f32 </span>}; <span class="number">1234</span>];
fft.process(<span class="kw-2">&amp;mut </span>buffer);</code></pre></div>
<p>The planner returns trait objects of the <a href="trait.Fft.html" title="trait rustfft::Fft"><code>Fft</code></a> trait, allowing for FFT sizes that aren’t known
until runtime.</p>
<p>RustFFT also exposes individual FFT algorithms. For example, if you know beforehand that you need a power-of-two FFT, you can
avoid the overhead of the planner and trait object by directly creating instances of the <a href="algorithm/struct.Radix4.html" title="struct rustfft::algorithm::Radix4"><code>Radix4</code></a> algorithm:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Computes a forward FFT of size 4096
</span><span class="kw">use </span>rustfft::{Fft, FftDirection, num_complex::Complex, algorithm::Radix4};

<span class="kw">let </span>fft = Radix4::new(<span class="number">4096</span>, FftDirection::Forward);

<span class="kw">let </span><span class="kw-2">mut </span>buffer = <span class="macro">vec!</span>[Complex{ re: <span class="number">0.0f32</span>, im: <span class="number">0.0f32 </span>}; <span class="number">4096</span>];
fft.process(<span class="kw-2">&amp;mut </span>buffer);</code></pre></div>
<p>For the vast majority of situations, simply using the <a href="struct.FftPlanner.html" title="struct rustfft::FftPlanner"><code>FftPlanner</code></a> will be enough, but
advanced users may have better insight than the planner into which algorithms are best for a specific size. See the
<a href="algorithm/index.html" title="mod rustfft::algorithm"><code>algorithm</code></a> module for a complete list of scalar algorithms implemented by RustFFT.</p>
<p>Users should beware, however, that bypassing the planner will disable all AVX, SSE and Neon optimizations.</p>
<h4 id="feature-flags"><a href="#feature-flags">Feature Flags</a></h4>
<ul>
<li>
<p><code>avx</code> (Enabled by default)</p>
<p>On x86_64, the <code>avx</code> feature enables compilation of AVX-accelerated code. Enabling it greatly improves performance if the
client CPU supports AVX and FMA, while disabling it reduces compile time and binary size.</p>
<p>On every platform besides x86_64, this feature does nothing, and RustFFT will behave like it’s not set.</p>
</li>
<li>
<p><code>sse</code> (Enabled by default)</p>
<p>On x86_64, the <code>sse</code> feature enables compilation of SSE4.1-accelerated code. Enabling it improves performance
if the client CPU supports SSE4.1, while disabling it reduces compile time and binary size. If AVX is also
supported and its feature flag is enabled, RustFFT will use AVX instead of SSE4.1.</p>
<p>On every platform besides x86_64, this feature does nothing, and RustFFT will behave like it’s not set.</p>
</li>
<li>
<p><code>neon</code> (Disabled by default)</p>
<p>On AArch64 (64-bit ARM) the <code>neon</code> feature enables compilation of Neon-accelerated code. Enabling it improves
performance, while disabling it reduces compile time and binary size.
Note that Rust’s Neon support requires using rustc 1.61 or newer.</p>
</li>
</ul>
<h4 id="normalization"><a href="#normalization">Normalization</a></h4>
<p>RustFFT does not normalize outputs. Callers must manually normalize the results by scaling each element by
<code>1/len().sqrt()</code>. Multiple normalization steps can be merged into one via pairwise multiplication, so when
doing a forward FFT followed by an inverse callers can normalize once by scaling each element by <code>1/len()</code></p>
<h4 id="output-order"><a href="#output-order">Output Order</a></h4>
<p>Elements in the output are ordered by ascending frequency, with the first element corresponding to frequency 0.</p>
<h4 id="avx-performance-tips"><a href="#avx-performance-tips">AVX Performance Tips</a></h4>
<p>In any FFT computation, the time required to compute a FFT of size N relies heavily on the <a href="https://en.wikipedia.org/wiki/Integer_factorization">prime factorization</a> of N.
If N’s prime factors are all very small, computing a FFT of size N will be fast, and it’ll be slow if N has large prime
factors, or if N is a prime number.</p>
<p>In most FFT libraries (Including RustFFT when using non-AVX code), power-of-two FFT sizes are the fastest, and users see a steep
falloff in performance when using non-power-of-two sizes. Thankfully, RustFFT using AVX acceleration is not quite as restrictive:</p>
<ul>
<li>Any FFT whose size is of the form <code>2^n * 3^m</code> can be considered the “fastest” in RustFFT.</li>
<li>Any FFT whose prime factors are all 11 or smaller will also be very fast, but the fewer the factors of 2 and 3 the slower it will be.
For example, computing a FFT of size 13552 <code>(2^4*7*11*11)</code> is takes 12% longer to compute than 13824 <code>(2^9 * 3^3)</code>,
and computing a FFT of size 2541 <code>(3*7*11*11)</code> takes 65% longer to compute than 2592 <code>(2^5 * 3^4)</code></li>
<li>Any other FFT size will be noticeably slower. A considerable amount of effort has been put into making these FFT sizes as fast as
they can be, but some FFT sizes just take more work than others. For example, computing a FFT of size 5183 <code>(71 * 73)</code> takes about
5x longer than computing a FFT of size 5184 <code>(2^6 * 3^4)</code>.</li>
</ul>
<p>In most cases, even prime-sized FFTs will be fast enough for your application. In the example of 5183 above, even that “slow” FFT
only takes a few tens of microseconds to compute.</p>
<p>Some applications of the FFT allow for choosing an arbitrary FFT size (In many applications the size is pre-determined by whatever you’re computing).
If your application supports choosing your own size, our advice is still to start by trying the size that’s most convenient to your application.
If that’s too slow, see if you can find a nearby size whose prime factors are all 11 or smaller, and you can expect a 2x-5x speedup.
If that’s still too slow, find a nearby size whose prime factors are all 2 or 3, and you can expect a 1.1x-1.5x speedup.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.num_complex"><code>pub use <a class="mod" href="../num_complex/index.html" title="mod num_complex">num_complex</a>;</code></div></li><li><div class="item-name" id="reexport.num_traits"><code>pub use <a class="mod" href="../num_traits/index.html" title="mod num_traits">num_traits</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="algorithm/index.html" title="mod rustfft::algorithm">algorithm</a></div><div class="desc docblock-short">Individual FFT algorithms</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.FftPlanner.html" title="struct rustfft::FftPlanner">FftPlanner</a></div><div class="desc docblock-short">The FFT planner creates new FFT algorithm instances.</div></li><li><div class="item-name"><a class="struct" href="struct.FftPlannerAvx.html" title="struct rustfft::FftPlannerAvx">FftPlannerAvx</a></div><div class="desc docblock-short">The AVX FFT planner creates new FFT algorithm instances which take advantage of the AVX instruction set.</div></li><li><div class="item-name"><a class="struct" href="struct.FftPlannerNeon.html" title="struct rustfft::FftPlannerNeon">FftPlannerNeon</a></div><div class="desc docblock-short">The Neon FFT planner creates new FFT algorithm instances using a mix of scalar and Neon accelerated algorithms.
It is supported when using the 64-bit AArch64 instruction set.</div></li><li><div class="item-name"><a class="struct" href="struct.FftPlannerScalar.html" title="struct rustfft::FftPlannerScalar">FftPlannerScalar</a></div><div class="desc docblock-short">The Scalar FFT planner creates new FFT algorithm instances using non-SIMD algorithms.</div></li><li><div class="item-name"><a class="struct" href="struct.FftPlannerSse.html" title="struct rustfft::FftPlannerSse">FftPlannerSse</a></div><div class="desc docblock-short">The SSE FFT planner creates new FFT algorithm instances using a mix of scalar and SSE accelerated algorithms.
It requires at least SSE4.1, which is available on all reasonably recent x86_64 cpus.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.FftDirection.html" title="enum rustfft::FftDirection">FftDirection</a></div><div class="desc docblock-short">Represents a FFT direction, IE a forward FFT or an inverse FFT</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Direction.html" title="trait rustfft::Direction">Direction</a></div><div class="desc docblock-short">A trait that allows FFT algorithms to report whether they compute forward FFTs or inverse FFTs</div></li><li><div class="item-name"><a class="trait" href="trait.Fft.html" title="trait rustfft::Fft">Fft</a></div><div class="desc docblock-short">Trait for algorithms that compute FFTs.</div></li><li><div class="item-name"><a class="trait" href="trait.FftNum.html" title="trait rustfft::FftNum">FftNum</a></div><div class="desc docblock-short">Generic floating point number, implemented for f32 and f64</div></li><li><div class="item-name"><a class="trait" href="trait.Length.html" title="trait rustfft::Length">Length</a></div><div class="desc docblock-short">A trait that allows FFT algorithms to report their expected input/output size</div></li></ul></section></div></main></body></html>